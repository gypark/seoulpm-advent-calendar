Title:    Mojolicious와 웹소켓 그리고 Redis
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   aanoaa

저자
-----

[@aanoaa][twitter-aanoaa] - 홍형석, 사당동 펠프스, [github:aanoaa][github-aanoaa]


시작하며
---------

[Mojolicious][home-mojolicious]은 인기있는 펄의 경량 웹 프레임워크입니다.
경량의 MVC 프레임워크임에도 불구하고 HTTP 클라이언트 및 서버의
거의 풀 스택을 구현한 웹 프레임워크로 지원하지 못하는 기능을
찾기가 더 어려울 정도인 잘 만들어진 모듈입니다.
웹소켓 역시 대표적인 예로 *Mojolicious*는 이 웹소켓을 아주 잘 지원합니다.
실시간으로 상태를 갱신한다던가 등의 동작을 단순 HTTP만으로 구현하려면
자바스크립트 및 웹응용의 컨트롤러에서 처리해야 할 내용이 꽤 많죠.
이번 기사에서는 *Mojolicious*에서 손쉽게 웹소켓을 다루는 방법을 소개합니다.


준비물
-------

필요한 모듈은 다음과 같습니다.

- [CPAN의 Mojolicious 모듈][cpan-mojolicious]
- [CPAN의 Mojo::Redis2 모듈][cpan-mojo-redis2]

[Mojo::Redis2][cpan-mojo-redis2] 모듈을 사용하려면 [Redis][home-redis] 서버를 설치해야 합니다.
데비안 계열의 리눅스를 사용하고 있다면 다음 명령을 이용해서 패키지를 설치합니다.

    #!bash
    $ sudo apt-get install redis-server

직접 [CPAN][cpan]을 이용해서 설치한다면 다음 명령을 이용해서 모듈을 설치합니다.

    #!bash
    $ sudo cpan Mojolicious Mojo::Redis2

사용자 계정으로 모듈을 설치하는 방법을 정확하게 알고 있거나
[perlbrew][home-perlbrew]를 이용해서 자신만의 Perl을 사용하고 있다면
다음 명령을 이용해서 모듈을 설치합니다.

    #!bash
    $ cpan Mojolicious Mojo::Redis2


# echo server/client #

[Writing websocket chat using Mojolicious Lite][mojo-wiki] 를 조금 변경했습니다.

    # echo
    #!/usr/bin/env perl
    use Mojolicious::Lite;
    use Time::HiRes 'time';
    
    get '/' => 'index';
    
    my %clients;
    websocket '/echo' => sub {
        my $self = shift;
        my $log  = $self->app->log;
        my $id   = time;
    
        $clients{$id} = $self->tx;
        $log->debug('[ws] client connected');
        $self->on(
            message => sub {
                my ( $self, $msg ) = @_;
                $log->debug("[ws] < $msg");
                for my $key ( keys %clients ) {
                    $clients{$key}->send($msg);
                    $log->debug("[ws] > ($id) $msg");
                }
            }
        );
    
        $self->on(
            finish => sub {
                $log->debug('[ws] client disconnected');
                delete $clients{$id};
            }
        );
    };
    
    app->start;
    
    __DATA__
    
    @@ index.html.ep
    
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <title>Echo client</title>
        <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
        <script>
          $(function() {
            var sock;
            var port = location.port;
            sock = new WebSocket('ws://localhost:' + port + '/echo');
            sock.onopen = function(e) {
              console.log('Connected');
            }
            sock.onmessage = function(e) {
              $('<p>' + e.data + '</p>').appendTo('#msg');
            };
    
            $('#txt').keydown(function (e) {
              $this = $(this)
              if (e.keyCode == 13 && $this.val()) {
                sock.send($this.val());
                $this.val('');
              }
            });
          });
        </script>
      </head>
      <body>
        <h1>Mojolicious + WebSocket</h1>
        <div id="msg">
        </div>
        <div>
          <input id="txt" type="text" />
        </div>
      </body>
    </html>

`Mojolicious` 의 모든 기능을 지원하는 http server 인 `morbo` 혹은
`hypnotoad` 로 실행 시켜야합니다.
`Starman` 이나 `Starlet` 으로는 Mojolicious 의 websocket 이 동작하지
않습니다.

    $ morbo echo

# 문제 #

위 예제는 http server 의 worker 가 한개 이상일때는 정상적으로 동작하지 않습니다.
메세지를 받은 worker 에 연결된 client 에만 전달되기 때문입니다.

# redis 의 활용 #

[redis-pubsub][redis-pubsub] 모델을 활용하면 위 문제가 너무나도
간단하게 해결됩니다.

메세지를 받은 worker 가 publish 하고 이를 subscribe 하고 있는 worker
들이 메세지를 받아서 연결되어있는 client 에 전달합니다.

# echo server/client using redis #

`__DATA__` 섹션은 위 `echo` 예제와 같습니다.

    # echo-redis
    #!/usr/bin/env perl
    use Mojolicious::Lite;
    use Mojo::Redis2;
    use Time::HiRes 'time';

    my $config = plugin 'Config';

    my $REDIS_CHANNEL = 'echo';
    
    helper redis => sub { shift->stash->{redis} ||= Mojo::Redis2->new; };
    
    get '/' => 'index';
    
    websocket '/echo' => sub {
        my $self = shift;
        my $log  = $self->app->log;
        my $name = time;
    
        $log->debug('[ws] client connected');
        $self->inactivity_timeout(60);    # 60 seconds
        Scalar::Util::weaken($self);
    
        $self->on(
            message => sub {
                my ( $self, $msg ) = @_;
                $log->debug("[ws] < $msg");
                $self->redis->publish( $REDIS_CHANNEL => $msg );
            }
        );
    
        $self->on(
            finish => sub {
                my ( $self, $code, $reason ) = @_;
                $log->debug("[ws] client disconnected with status $code");
                delete $self->stash->{redis};
            }
        );
    
        $self->redis->on(
            message => sub {
                my ( $redis, $message, $ch ) = @_;
                return if $ch ne $REDIS_CHANNEL;
                return unless $self;
                $log->debug("[ws] > ($name) $message");
                $self->send($message);
            }
        );
    
        $self->redis->subscribe(
            $REDIS_CHANNEL => sub {
                my ( $redis, $err ) = @_;
                $log->error("[REDIS ERROR] subscribe error: $err") if $err;
            }
        );
    };
    
    app->start;

여러개의 worker 를 띄우기 위해서 `hypnotoad` 설정을 해야합니다.

    # echo-redis.conf
    { hypnotoad => { listen => ["http://*:5000"], workers => 5 } };

실행은

    $ hypnotoad -f echo-redis

# 정리하며 #

묵묵히 perl 을 사용해서 web 프로그래밍을 하시는 분들에게 도움이
되었으면 합니다.


[cpan]:             http://www.cpan.org/
[github-aanoaa]:    https://github.com/aanoaa
[home-mojolicious]: http://mojolicio.us/
[home-perlbrew]:    http://perlbrew.pl/
[home-redis]:       http://redis.io/
[mojo-wiki]:        https://github.com/kraih/mojo/wiki/Writing-websocket-chat-using-Mojolicious-Lite
[redis-pubsub]:     http://redis.io/topics/pubsub
[twitter-aanoaa]:   https://twitter.com/aanoaa
