Title:    use Complete::Bash;
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   John_Kang

저자
-----

John_Kang - 시스템엔지니어


시작하며
---------

펄을 접할 때 단연코 가장 흥미로운 것은 "*게으름은 미학이다!*"라는 [철학][three-virtues]입니다.
게으름(laziness) 그 자체를 어떻게 바라보는지는 크게 관심 없습니다만,
게을러지기 위한 노력들은 삶을 윤택(?)하게 만들어 주기 때문이 아닐까합니다.
이번에 다룰 주제를 통해서 다시 한번 게을러 보고자 합니다 :)

인기있는 유용한 유틸리티들은 항상 다양한 기능을 제공하기 위해
명령줄 옵션을 제공할 뿐만 아니라 때때로 부명령(subcommand)까지도 지원합니다.
하지만 이런 다양한 명령과 옵션을 오랫동안 기억하는 것은 쉬운 일이 아닙니다.
심지어 입력하다보면 오타가 발생하기도 하죠.
`--help` 옵션을 이용해 도움말을 확인하면 될 일이지만, 번거롭긴 합니다.

자! 좀 더 게을러보죠!!! :-)


준비물
-------

필요한 모듈은 다음과 같습니다.

- [CPAN의 Complete::Bash 모듈][cpan-complete-bash]
- [CPAN의 Complete::Util 모듈][cpan-complete-util]
- 설치된 [perlbrew][home-perlbrew]

직접 [CPAN][cpan]을 이용해서 설치한다면 다음 명령을 이용해서 모듈을 설치합니다.

    #!bash
    $ sudo cpan Complete::Bash Complete::Util

사용자 계정으로 모듈을 설치하는 방법을 정확하게 알고 있거나
[perlbrew][home-perlbrew]를 이용해서 자신만의 Perl을 사용하고 있다면
다음 명령을 이용해서 모듈을 설치합니다.

    #!bash
    $ cpan Complete::Bash Complete::Util


쉘 자동완성
------------

우선 쉘이 커멘드 라인을 어떻게 파싱 하는지 알 필요가 있습니다.
- 쉘에서 주어진 인자들을 하나 이상의 공백으로 구분한다.
- 첫번째 인자는 무조건 명령어 이다.(`$PATH` 에 있거나 절대 경로)

두번째 규칙이 너무 저희에게 너무나 친숙하여 규칙인것을 잘 인지 하지 못하는 경우도 있습니다.
명령어의 자동완성 기능은 항상 첫번째 인자에서만 활성화 됩니다.
두번째 인자에서는 명령어를 자동완성 시켜 주지 못합니다.
물론 `time`과 같이 명령어를 인자로 취하는 경우는 쉘의 커멘드라인 파싱의 규칙에 의해서 파싱 되는것이 아니라.
`complete`에 미리 정의된 함수에 의해 2번째인자로 실행 가능한 명령어를 찾습니다.


Bash Completion
----------------

`bash`는 다양한 방법으로 자동완성을 시켜주는 `complete` 내장함수를 사용할 수 있도록 합니다.
somecmd명령어에 대해서 `Wordlist`를 작성해 두고 사용할 수 있으며,

    #!bash
    $ complete -W "one two three four" somecmd
    $ somecmd t<TAB><TAB>
    two  three

아래와 같이 함수(-F)를 사용할수 도 있으며,
해당 함수는 2개의 input인자를 전달 받게 됩니다.

- `COMP_WORDS` : 인자 리스트
- `COMP_CWORD` : 배열 인덱스(현재 커서의 위치)

그리고 반드시 `COMPREPLY`에 사용 가능한 자동완성 요소 리스트를 담아야 합니다.

    #!bash
    $ _foo()
    {
        local cur
        COMPREPLY=()
        cur=${COMP_WORDS[COMP_CWORD]}
        COMPREPLY=($( compgen -W '--help --verbose --version' -- $cur ) )
    }
    $ complete -F _foo foo
    $ foo <TAB><TAB>
    --help  --verbose  --version


Complete::Bash
---------------

또다른 방법으로 펄등의 외부명령어 실행을 통하여 자동완성 리스트를 만들수 있습니다.

[perlbrew][home-perlbrew] 명령어에 `complete`를 작성 해보겠습니다.


### 쉘로 전달된 인자 파싱

가장먼저 쉘에서 `<TAB><TAB>`키가 눌렸을때 전달된 인자가 무엇인지를 확인해야 합니다.
[Complete::Bash][cpan-complete-bash]모듈이 제공하는 `parse_cmdline()` 함수를 통해 쉘의 인자들을 파싱할 수 있습니다.
실제로는 인자를 그대로 파싱하는것이 아니라 `bash`로 부터 전달된 `COMP_LINE`, `COMP_POINT` 환경변수를 파싱합니다.
`parse_cmdline()`는 아래와 같은 구조로 파싱된 결과를 리턴합니다.

- Return : [ [], $cur_idx ]
- 명령줄에 전달된 모든 인자와, 현재 커서의 인덱스를 배열 레퍼런스로 리턴합니다.

`$cur_idx`는 `<TAB><TAB>`을 사용한 시점의 cursor의 인덱스 값입니다.

    #!perl
    #!/usr/bin/env perl

    use strict;
    use warning;

    use Complete::Bash qw( parse_cmdline format_completion );
    use Complete::Util qw( complete_array_elem );

    my ( $words, $cur_idx ) = @{ parse_cmdline() };                                             
    my $given = $words->[$cur_idx];

    ## from bash : perlbrew <TAB><TAB>
    ## $words   = [ 'perlbrew', '' ];
    ## $cur_idx = 1;
    ## <TAB><TAB>을 타이핑한 시점에 명령줄에서 정의된 인자 리스트는 총 2개 입니다.
    ## perlbrew 명령어와 작성중인 2번째 인자 입니다.
    ## 현재 커서는 2번째 배열인덱스에 있으므로 커서의 값은 배열 인덱스인 1입니다.


### 자동완성 리스트 작성/출력

`perlbrew` 명령어는 주동작을 결정짓는 command를 필수 인자로 취하고 부가적인 옵션들을 취합니다.

    #!plain
    Usage : perlbrew <command> [options] [arguments]

먼저 command에 해당하는 부분에 대해서 자동완성을 작성합니다.

[Complete::Util][cpan-complete-util]모듈이 제공하는 `complete_array_elem()` 함수는 미리 작성된 자동완성 리스트와
검색에 사용할 문자열을 취하여 사용가능한 자동완성 리스트를 반환 합니다.
그리고 우리는 [Complete::Bash][cpan-complete-bash] 모듈이 제공하는 `format_completion()`함수를 통해서 출력하면 됩니다.

    #!perl
    if ( $cur_idx == 1 ) { 
        my $complete = complete_array_elem(
            array => [qw/
                init info install uninstall available lib alias
                upgrade-perl list use off switch switch-off exec
                self-install self-upgrade install-patchperl install-cpanm
                install-multiple download mirror clean version help
            /],               ## 자동완성 리스트
        
            word  => $given,  ## 검색할 문자열
        );  

        print format_completion $complete;
    }


perlbrew의 필수 인자인 <command> 부분의 자동완성을 완성했습니다.
이제 해당 커멘드에 필요한 option 및 argument를 작성 해보겠습니다.

### 옵션이 필요 없는 command

`init`, `list`, `off`, `switch-off`, `install-cpanm`, `install-patchperl`, `self-upgrade`, `version` 등등의 명령어는
옵션을 필요로 하지 않기 때문에 더 이상의 자동완성을 필요로 하지 않습니다.

헐... `man page` 자세히 보니 Genric command option이 있군요...

    #!plain
    Generic command options:
        -q --quiet     Be quiet on informative output message.
        -v --verbose   Tell me more about it.


명령줄에서 전달된 리스트에서 마지막 2번째 요소를 확인하면(`$words[-2]`) perlbrew 커맨드를 확인할 수 있습니다.

    #!perl
    if ( $words->[-2] eq 'init'              ||
         $words->[-2] eq 'list'              ||
         $words->[-2] eq 'off '              ||
         $words->[-2] eq 'switch-off'        ||
         $words->[-2] eq 'install-cpanm'     ||
         $words->[-2] eq 'install-patchperl' ||
         $words->[-2] eq 'self-upgrade'      ||
         $words->[-2] eq 'version'           ||
         $words->[-2] eq 'upgrade-perl'      ||
         $words->[-2] eq 'list-modules' ) {

        generic_options($given);
    }

    sub generic_options {                                                                       
        my ($given) = @_;
        completion( [qw/ --quite --verbose /], $given );
    }

    sub completion {
        my ( $available_opts, $given ) = @_; 

        my $res = complete_array_elem(
            array => $available_opts,    
            word  => $given,
        );  

        print format_completion $res;
        exit 0;
    }


### 옵션이 필요한 info

`info` 명령어는 모듈을 인자로 취하여 해당 모듈의 정보를 출력해 줍니다.
`perlbrew list-module` 명령어 통해서 획득한 리스트를 사용하여 이를 자동완성 시켜 줍니다.

    #!perl
    if ( $words->[-2] eq 'info' ) {
        completion( list_modules(), $given );
    }

    sub list_modules {
        my @modules = qx(perlbrew list-modules);
                                                                                                
        return [ map { chomp; $_ } @modules ];
    }

    sub completion {
        my ( $available_opts, $given ) = @_; 

        my $res = complete_array_elem(
            array => $available_opts,    
            word  => $given,
        );  

        print format_completion $res;
        exit 0;
    }


### switch uninstall use

`switch`, `uninstall`, `use` 명령어들은 현재 perlbrew에 설치된 Perl 버전정보를 인자로 취합니다.

    #!perl
    if ( $words->[-2] eq 'uninstall' ||
         $words->[-2] eq 'use'       ||
         $words->[-2] eq 'switch' ) {

        completion( installed_perl(), $given );
    }

    sub installed_perl {
        my @installed_perl = qx(perlbrew list);
        return [ map { /(perl-\d\.\d\d\.\d)/ } @installed_perl ];
    }

    sub completion {
        my ( $available_opts, $given ) = @_; 

        my $res = complete_array_elem(
            array => $available_opts,    
            word  => $given,
        );  

        print format_completion $res;
        exit 0;
    }

`perlbrew list` 커맨드로 획득한 펄 버전정보들을 자동완성 리스트로 활용합니다.


적용하기
---------

작성된 스크립트를 사용하기 위해서는 2가지 조건이 필요합니다.

실행권한 추가 그리고 `complete` 등록

    #!bash
    $ chmod +x completion-perlbrew.pl
    $ complete -C completion-perlbrew.pl perlbrew

해당 스크립트가 실행 가능한 `PATH` 에 위치하거나 절대 경로로 등록을 해주어야 합니다.

    #!bash
    $ complete -C /home/user/bin/completion-perlbrew.pl perlbrew

    or

    $ export PATH=$PATH:/home/user/bin

`.bashrc`등에 등록하여 사용하실수도 있습니다.


정리하며
---------

지금까지 리눅스 내장 명령어인 `complete`와 펄이 어떻게 조화를 이룰 수 있는지 살펴 보았습니다.
이번 기사에서 간단한 부분을 언급하여 소개하였으나 `Complete::Bash`와 `Complete::Util`의 모듈 문서를
참고하시면 조금더 정교한 방법으로 사용할 수 있습니다.
사용자 프로그램을 배포할때도 completion script를 같이 배포하여
프로그램의 질을 한번 높여 보는것도 좋은 방법인것 같습니다.


완성본
-------

지금까지 살표본것들을 종합한 스크립트 입니다.

    #!perl
    #!/usr/bin/env perl

    use strict;
    use warnings;

    use Complete::Bash qw( parse_cmdline format_completion );
    use Complete::Util qw( complete_array_elem );

    my ( $words, $cur_idx ) = @{ parse_cmdline() };
    my $given = $words->[$cur_idx];

    if ( $cur_idx == 1 ) {
        my $complete = complete_array_elem(
            array => [qw/
                init info install uninstall available lib alias
                upgrade-perl list use off switch switch-off exec
                self-install self-upgrade install-patchperl install-cpanm
                install-multiple download mirror clean version help
            /],
                        
            word  => $given,
        );

        print format_completion $complete;
    }

    if ( $words->[-2] eq 'init'              ||
         $words->[-2] eq 'list'              ||
         $words->[-2] eq 'off '              ||
         $words->[-2] eq 'switch-off'        ||
         $words->[-2] eq 'install-cpanm'     ||
         $words->[-2] eq 'install-patchperl' ||
         $words->[-2] eq 'self-upgrade'      ||
         $words->[-2] eq 'version'           ||
         $words->[-2] eq 'upgrade-perl'      ||
         $words->[-2] eq 'list-modules' ) {

        generic_options($given);
    }

    if ( $words->[-2] eq 'info' ) {
        completion( list_modules(), $given );
    }

    if ( $words->[-2] eq 'install' ) {
        my $install_opt = [qw/
            -f --force -j -n --notest --switch --as --noman --thread
            --multi --64int --64all --ld --debug --clang -D -U -A
            --sitecustomize
        /];
        completion( $install_opt, $given );
    }

    if ( $words->[-2] eq 'available' ) {
        completion( [qw / --all /], $given );
    }

    if ( $words->[-2] eq 'uninstall' ||
         $words->[-2] eq 'use'       ||
         $words->[-2] eq 'switch' ) {

        completion( installed_perl(), $given );
    }


    ## subroutine
    sub completion {
        my ($available_opts, $given) = @_;
        my $res = complete_array_elem(
            array => $available_opts,                    
            word  => $given,
        );

        print format_completion $res;
        exit 0;
    }

    sub installed_perl {
        my @installed_perl = qx(perlbrew list);

        return [ map { /(perl-\d\.\d\d\.\d)/ } @installed_perl ];
    }

    sub list_modules {
        my @modules = qx(perlbrew list-modules);

        return [ map { chomp; $_ } @modules ];
    }

    sub generic_options {
        my ($given) = @_;
        completion([qw/ --quite --verbose /], $given);
    }


참고문헌
--------
[위키피디아][wikipedia-completion]


_EOT_


[cpan-complete-bash]:   https://metacpan.org/pod/Complete::Bash
[cpan-complete-util]:   https://metacpan.org/pod/Complete::Util
[cpan]:                 http://www.cpan.org/
[home-perlbrew]:        http://perlbrew.pl/
[three-virtues]:        http://c2.com/cgi/wiki?LazinessImpatienceHubris
[wikipedia-completion]: http://en.wikipedia.org/wiki/Command-line_completion
