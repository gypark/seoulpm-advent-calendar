Title:    SMART 체크 - 디스크 검사
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   aqua

저자
-----

aqua - 두마리 고양이의  집사. 직관 잘 안 가는 fc서울 서포터, aquative _at_ gmail.com


시작하며
-----

S.M.A.R.T 체크 - 디스크 검사

서버에 발생하는 문제중에서 빈번하지는 않지만(서비스 종류에 따라 다릅니다) 크리티컬한 문제가 디스크 문제가 생긴 경우입니다.
그러므로 평소에 모니터링을 해서 미리 디스크 교체와 같은 조치를 할 수 있도록 해야 합니다.

많이 쓰는 디스크 검사 방법은 [smartmontools][smartmontools]를 이용한 검사입니다.
제가 소개하는 것은 smartmontools 패키지의 smartctl를 실행하고 결과를 간단히 분석하고 판단해서 알려주는 펄 프로그램입니다.

smartctl를 실행하고 결과를 분석하기 위해서 [CPAN의 Capture::Tiny][cpan-capture-tiny] 모듈과 함께
모니터링 시스템(Opsview)과 같이 사용하기 위해서 [CPAN의 Nagios::Plugin][cpan-nagios-plugin] 모듈도 사용합니다.


준비물
-----

필요한 모듈은 다음과 같습니다.

* [CPAN의 Nagios::Plugin 모듈][cpan-nagios-plugin]
* [CPAN의 Capture::Tiny 모듈][cpan-capture-tiny]

직접 [CPAN][cpan]을 이용해서 설치한다면 다음 명령을 이용해서 모듈을 설치합니다.

    $ sudo cpan Nagios::Plugin
    $ sudo cpan Capture::Tiny

사용자 계정으로 모듈을 설치하는 방법을 정확하게 알고 있거나
[perlbrew][home-perlbrew]를 이용해서 자신만의 Perl을 사용하고 있다면
다음 명령을 이용해서 모듈을 설치합니다.

    $ cpan Nagios::Plugin
    $ cpan Capture::Tiny

그리고 smartmontools 패키지를 설치합니다.

    # RHEL/CentOS
    $ yum -y install smartmontools
    
    # Debian
    $ aptitude -y install smartmontools


smartctl 옵션
-----

디스크 검사에 사용할 옵션입니다.

    -H health 상태 값을 확인 합니다.
    -A attributes 상태 값을 확인 합니다.

모니터링에 사용하는 attributes 항목입니다.

    UDMA_CRC_Error_Count
    Reallocated_Event_Count
    Reallocated_Sector_Ct
    Offline_Uncorrectable
    Spin_Retry_Count
    Current_Pending_Sector

참고로 attributes 항목은 [이곳][attributes]을 참고했습니다.


명령 만들기
-----

smartctl 명령을 실행 하기 위한 명령을 만드는 함수입니다.

사용자가 실행 할 때 입력한 옵션과 @disk 배열에 있는 디스크 정보를 이용해서 명령문을 생성합니다.
디스크가 1개이면 한개의 명령문이 생성됩니다. 하지만 디스크가 여러개가 있을 수 있기 때문에 배열을 사용합니다.

	my $opt = shift;
	my @disk = @_;
	my @cmd;

	$opt = '-H' if $opt eq 'health';
	$opt = '-A' if $opt eq 'attributes';

디스크는 한개 이상이므로 loop 문을 사용합니다.

	for my $i ( @disk ) {
	    push @cmd, sprintf "/usr/sbin/smartctl $opt /dev/%s", $i;
	}

	return @cmd;


실행
-----
명령을 실행하고 결과를 리턴하는 함수입니다.
명령을 실행하고 exit 값을 확인 합니다. exit 값이 0이면 성공으로 판단하고, 0이 아니면 성공하지 못 한걸로 판단합니다.
exit 값이 0이 아니면 사용자가 직접 명령을 실행하고 상태 확인을 해야 합니다.

    for my $i ( @cmd ) {
        my ($stdout, $stderr, $exit) = capture {
            system $i
        };

0이 아니므로 정상 종료가 아닙니다.

        if ( $exit != 0 ) {
            $res{execute} = 0;
            return %res;
        }

정상 종료!

        else {
            $res{execute} = 1;
        }

사용자가 입력한 옵션에 따라서 실행이 다릅니다.

        if ( $opt eq 'health' ) {
            ($res{$dev}{health}) = $stdout =~ m{SMART overall-health self-assessment test result: (\w+)}g;
        } else {
             my @output = split q{[\r\n]+}, $stdout;

            for my $res ( @output ) {
                my @d = split q{ }, $res;

지정한 attributes 정보 값만 변수에 저장합니다.

                for my $i ( @{ $attr } ) {
                    $res{$dev}{ $i } = $d[-1] if $d[1] eq $i;
                }
            }
        }
    }


main 함수 및 결과 분석 그리고 모니터링(Opsview) 알림
-----

main 함수는 3가지 기능을 합니다.

* 사용자로부터 옵션을 입력 받습니다.
* 생성한 명령을 실행하는 함수를 호출 합니다.
* 실행 결과를 분석합니다.

사용자가 프로그램을 실행 할 때 입력한 옵션입니다.

    my $check_target = $ARGV[0] || 'health'; # 입력이 없으면 기본값을 'health'로 셋팅한다.
    my @mode = qw( health attributes );

smart 결과에 문제가 있는 경우, $do_notify의 값을 증가 시켜셔 알람 행동을 판단합니다.

    my $do_notify = 0;

attributes 항목에서 모니터링 대상과 threshold값입니다.

    my %cond_attr = qw(
      Spin_Retry_Count         1
      Reallocated_Sector_Ct    0
      Reallocated_Event_Count  0
      Current_Pending_Sector   0
      Offline_Uncorrectable    0
      UDMA_CRC_Error_Count     0
    );

프로그램을 실행 할 때 입력한 옵션이 올바른지 확인하고,
틀리면 안내문을 출력하고 프로그램을 종료합니다.

    unless ( grep { m{^$check_target$} } @mode ) {
        print "Usage: check_smart.pl { health | attributes }\n";
        exit 1;
    }

알람을 하기 위해서 `Nagios::Plugin` 객체를 생성합니다.

    my $np = Nagios::Plugin->new();

디스크 정보를 받습니다.

    my @disk = get_disk_info();

디스크 정보를 이용해서 명령을 생성합니다.

    my @cmd = make_cmd($check_target, @disk);

생성한 명령 실행

    my %res;
    {
    	# attributes 정보를 얻기 위해서 키 값을 추출한다.
        my @attr = map {
            $_
        } keys %cond_attr;

        %res = exe_check($check_target, \@attr, @cmd);
    }

명령 실행에 실패 하면 Opsview의 unknown 경고 알람을 하고 프로그램을 종료 합니다.

    $np->nagios_exit(UNKNOWN, "check to smartctl path or permission") unless $res{execute};

health 검사 결과를 분석하는 구문입니다.

     if ( $check_target eq 'health' ) {
        for my $i ( keys %res ) {
            next if $i eq 'execute';
            next unless defined $res{$i}{health};

검사 결과가 PASSED 가 아니면 디스크에 문제가 있습니다.
그러므로 nagios 알림을 하기 위해서 `$do_notify`의 값을 증가합니다.

            $do_notify++ if $res{$i}{health} ne 'PASSED';

            $msg .= "$i: [$res{$i}{health}]";
            $msg .= " ";
        }

        $msg =~ s{[[:space:]]$}{} if $msg;
    }

attributes 검사 결과를 분석하는 구문입니다.

    if ( $check_target eq 'attributes' ) {
        for my $i ( keys %res ) {
            next if $i eq 'execute';
            for my $a ( keys %cond_attr ) {
                if ( exists $res{$i}{$a} and defined $res{$i}{$a} ) {

모니터링 대상 attributes 항목이면 threshold 값을 비교합니다.
지정한 threshold 값보다 크면 모니터링 알람을 하기 위해서 `$do_notify`의 값을 증가합니다.

                    if ( $res{$i}{$a} > $cond_attr{$a} ) {
                        $do_notify++;
                        $msg .= "$i: $a [$res{$i}{$a}]\n";
                    } else {
                        $msg .= "$i: $a [OK]\n";
                    }
                }
            }
        }
    }

모니터링 알람을 합니다.

        if ( $do_notify ) {
            $np->nagios_exit(CRITICAL, $msg);
        } else {
            $np->nagios_exit(OK, $msg);
        }
    }


테스트
-----

실행할 장비에는 디스크가 `sda`, `sdb` 2개가 있습니다.
smartctl을 실제로 실행한 결과입니다.

`sda`에 대한 health 검사

    root@hubble:~# smartctl -H /dev/sda
    smartctl 6.2 2013-07-26 r3841 [x86_64-linux-3.13.0-27-generic] (local build)
    Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org

    === START OF READ SMART DATA SECTION ===
    SMART overall-health self-assessment test result: PASSED

`sda`에 대한 attributes 검사

    root@hubble:~# smartctl -A /dev/sda
    smartctl 6.2 2013-07-26 r3841 [x86_64-linux-3.13.0-27-generic] (local build)
    Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org

    === START OF READ SMART DATA SECTION ===
    SMART Attributes Data Structure revision number: 16
    Vendor Specific SMART Attributes with Thresholds:
    ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
      1 Raw_Read_Error_Rate     0x000b   100   100   016    Pre-fail  Always       -       65536
      2 Throughput_Performance  0x0005   139   139   054    Pre-fail  Offline      -       73
      3 Spin_Up_Time            0x0007   144   144   024    Pre-fail  Always       -       404 (Average 393)
      4 Start_Stop_Count        0x0012   100   100   000    Old_age   Always       -       27
      5 Reallocated_Sector_Ct   0x0033   100   100   005    Pre-fail  Always       -       0
      7 Seek_Error_Rate         0x000b   100   100   067    Pre-fail  Always       -       0
      8 Seek_Time_Performance   0x0005   124   124   020    Pre-fail  Offline      -       33
      9 Power_On_Hours          0x0012   099   099   000    Old_age   Always       -       11327
     10 Spin_Retry_Count        0x0013   100   100   060    Pre-fail  Always       -       0
     12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       27
    192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       28
    193 Load_Cycle_Count        0x0012   100   100   000    Old_age   Always       -       28
    194 Temperature_Celsius     0x0002   200   200   000    Old_age   Always       -       30 (Min/Max 18/42)
    196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0
    197 Current_Pending_Sector  0x0022   100   100   000    Old_age   Always       -       0
    198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       0
    199 UDMA_CRC_Error_Count    0x000a   200   200   000    Old_age   Always       -       0

그리고 펄 프로그램으로 실행한 health 검사 결과 입니다.

    root@hubble:~# perl check_smart.pl
    SMART OK - /dev/sda: [PASSED] /dev/sdb: [PASSED]

그리고 펄 프로그램으로 실행한 attributes 검사 결과 입니다.

    root@hubble:~# perl check_smart.pl attributes
    SMART OK - /dev/sda: UDMA_CRC_Error_Count [OK]
     /dev/sda: Reallocated_Event_Count [OK]
     /dev/sda: Reallocated_Sector_Ct [OK]
     /dev/sda: Offline_Uncorrectable [OK]
     /dev/sda: Spin_Retry_Count [OK]
     /dev/sda: Current_Pending_Sector [OK]
     /dev/sdb: UDMA_CRC_Error_Count [OK]
     /dev/sdb: Reallocated_Event_Count [OK]
     /dev/sdb: Reallocated_Sector_Ct [OK]
     /dev/sdb: Offline_Uncorrectable [OK]
     /dev/sdb: Spin_Retry_Count [OK]
     /dev/sdb: Current_Pending_Sector [OK]


전체코드
-----


    #!/usr/bin/env perl
    # requirement package: smartmontools
    use utf8;
    use strict;
    use warnings;

    use Capture::Tiny qw( capture );
    use Nagios::Plugin;
    use Data::Dumper;

    sub get_disk_info {
        my $disk_info = '/proc/partitions';
        my @disk;

        open my $fh, '<', $disk_info or die "$!\n";
        while ( <$fh> ) {
            push @disk, ( split q{ }, $_ )[-1] if $_ =~ m{sd[a-z]$}g;
        }
        close $fh;

        return @disk;
    }

    sub make_cmd {
        my $opt = shift;
        my @disk = @_;
        my @cmd;

        $opt = '-H' if $opt eq 'health';
        $opt = '-A' if $opt eq 'attributes';

        for my $i ( @disk ) {
            push @cmd, sprintf "/usr/sbin/smartctl $opt /dev/%s", $i;
        }

        return @cmd;
    }

    sub exe_check {
        my $opt = shift;
        my $attr = shift;
        my @cmd = @_;
        my %res;

        for my $i ( @cmd ) {
            my ($stdout, $stderr, $exit) = capture {
                system $i
            };

            if ( $exit != 0 ) {
                $res{execute} = 0;
                return %res;
            } else {
                $res{execute} = 1;
            }

            my $dev = ( split q{ }, $i )[-1];

            if ( $opt eq 'health' ) {
                ($res{$dev}{health}) = $stdout =~ m{SMART overall-health self-assessment test result: (\w+)}g;
            } else {
                 my @output = split q{[\r\n]+}, $stdout;

                for my $res ( @output ) {
                    my @d = split q{ }, $res;

                    for my $i ( @{ $attr } ) {
                        $res{$dev}{ $i } = $d[-1] if $d[1] eq $i;
                    }
                }
            }
        }

        return %res;
    }

    sub main {
        my $check_target = $ARGV[0] || 'health';
        my @mode = qw( health attributes );
        my $msg;
        my $do_notify = 0;
        my %cond_attr = qw(
          Spin_Retry_Count         1
          Reallocated_Sector_Ct    0
          Reallocated_Event_Count  0
          Current_Pending_Sector   0
          Offline_Uncorrectable    0
          UDMA_CRC_Error_Count     0
        );

        unless ( grep { m{^$check_target$} } @mode ) {
            print "Usage: check_smart.pl { health | attributes }\n";
            exit 1;
        }

        my $np = Nagios::Plugin->new();

        # get disk info
        my @disk = get_disk_info();

        # command
        my @cmd = make_cmd($check_target, @disk);

        # execute
        my %res;
        {
            my @attr = map {
                $_
            } keys %cond_attr;

            %res = exe_check($check_target, \@attr, @cmd);
        }

        # parsing execute results
        $np->nagios_exit(UNKNOWN, "smartctl return value is false, check to smartctl path or permission") unless $res{execute};

        if ( $check_target eq 'health' ) {
            for my $i ( keys %res ) {
                next if $i eq 'execute';
                next unless defined $res{$i}{health};
                $do_notify++ if $res{$i}{health} ne 'PASSED';

                $msg .= "$i: [$res{$i}{health}]";
                $msg .= " ";
            }

            $msg =~ s{[[:space:]]$}{} if $msg;
        }

        if ( $check_target eq 'attributes' ) {
            for my $i ( keys %res ) {
                next if $i eq 'execute';
                for my $a ( keys %cond_attr ) {
                    if ( exists $res{$i}{$a} and defined $res{$i}{$a} ) {
                        if ( $res{$i}{$a} > $cond_attr{$a} ) {
                            $do_notify++;
                            $msg .= "$i: $a [$res{$i}{$a}]\n";
                        } else {
                            $msg .= "$i: $a [OK]\n";
                        }

                        $msg .= " ";
                    }
                }
            }
            $msg =~ s{[[:space:]]$}{} if $msg;
        }

        # do notify
        if ( $do_notify ) {
            $np->nagios_exit(CRITICAL, $msg);
        } else {
            $np->nagios_exit(OK, $msg);
        }
    }

    main;


__EOT__
[smartmontools]:        http://www.smartmontools.org
[attributes]:           http://www.thomas-krenn.com/en/wiki/Smartctl
[cpan-nagios-plugin]:   https://metacpan.org/pod/Nagios::Plugin
[cpan-capture-tiny]:    https://metacpan.org/pod/Capture::Tiny
[cpan]:                 http://www.cpan.org/
[home-perlbrew]:        http://perlbrew.pl/
