Title:    p5-hubot: 날씨봇 만들기
Package:  Seoul.pm
Category: perl
Category: Seoul.pm
Author:   newbcode

저자
@newbcode - 사랑스런 딸바보 도치파파

시작하며
혹시 휴봇(Hubot)이라고 들어보셨나요?
휴봇은 github에서 만든것으로 사내 private source로 만들어졌지만 많은 발전을 거듭하며, 현재는 오픈소스로 공개되어 있습니다.
github에서는 그룹채팅을 하면서 신입사원또는 사내업무에 대해서 질문을 하면 휴봇이 답변을 하는 식으로 개발 되었습니다.
예를 들어서 신입사원이 그룹채팅방에 들어와 "github xx부서에 핵심업무를 알려줘" 라고 물어보면 휴봇은 업무의 프로세스를 상세히
답변하고 더 발전하여 채팅룸에서 바로 실행 확인까지 가능합니다.
Node.js 기반에 CoffeeScript로 개발되었지만 aaona님께서 perl로 포팅 하였습니다. 너무너무 감사한일이죠 :) 
p5-hubot의 자세한 설명은 2012년 12월 02일자 기사(http://advent.perl.kr/2012/2012-12-02.html)를 참고 하세요
ps. 2012년12월02일자 기사를 먼저 읽으셔야 합니다! ㅎㅎㅎ

준비물
직접 cpan을 이용해서 설치한다면 다음 명령을 이용해서 모듈을 설치합니다.
$sudo cpan Hubot

날씨 알림 봇 만들기
irc에서 놀다보면 여러가지 정보를 확인하고 싶은경우가 많은데요 그중에 역시 날씨가 제일 궁금합니다(저만 그런가요???)
irc에서 날씨를 볼수 있는 봇을 만들어 보겠습니다.
날씨를 보는게 우리나라 기상청에서 정보를 얻어올수도 있구요 yahoo api를 이용해서 가져올수도 있겠죠?
우선 완성된 코드를 먼저 보겠습니다.

완성된 코드

package Hubot::Scripts::weather;
# ABSTRACT: Weather Script for Hubot. 

use utf8;
use strict;
use warnings;
use LWP::UserAgent;
use Data::Printer;
use Encode;

sub load {
    my ( $class, $robot ) = @_;
 
    $robot->hear(
        qr/^forecast (.+)/i,    
        \&forecast_process,
    );
    $robot->hear(
        qr/^weather (.+)/i,    
        \&current_process,
    );
    $robot->hear(
        qr/^@(.+)$/i,    
        \&current_process,
    );
    $robot->hear(
        qr/@(\d+\.\d+\.\d+\.\d+$)/i,    
        #qr/\.*?@(\d+\.\d+\.\d+\.\d+)\) has joined \#perl\-kr/i,    
        \&parser_ip,
    );
}

sub forecast_process {
    my $msg = shift;
    my $user_country = $msg->match->[0];

    my $woeid = woeid_process($msg, $user_country);

    if ( $woeid =~ /^\d+/) {
        my @weekly = condition_process($woeid, 'weekly');
        $msg->send("[$weekly[0]"." $weekly[1]]"." Low/High[$weekly[2]℃ /$weekly[3]℃ ]"." Condition[$weekly[4]]");
        $msg->send("[$weekly[5]"." $weekly[6]]"." Low/High[$weekly[7]℃ /$weekly[8]℃ ]"." Condition[$weekly[9]]");
        $msg->send("[$weekly[10]"." $weekly[11]]"." Low/High[$weekly[12]℃ /$weekly[13]℃ ]"." Condition[$weekly[14]]");
        $msg->send("[$weekly[15]"." $weekly[16]]"." Low/High[$weekly[17]℃ /$weekly[18]℃ ]"." Condition[$weekly[19]]");
        $msg->send("[$weekly[20]"." $weekly[21]]"." Low/High[$weekly[22]℃ /$weekly[23]℃ ]"." Condition[$weekly[24]]");
    }
    else {
        $msg->send($woeid);
    }
}

sub current_process {
    my $msg = shift;
    my $user_country = $msg->match->[0];

    my $woeid = woeid_process($msg, $user_country);

    if ( $woeid =~ /^\d+/) {
        my %current = condition_process($woeid, 'current');
        $msg->send("$current{location}"."[ LastTime:$current{date} ]");
        $msg->send("The status of current weather-[$current{condition}]"." temp-[$current{temp}℃ ]"." humidity-[$current{humidty}%]" .
               " direction- [$current{direction}km]"." speed-[$current{speed}km/h]"." sunrise/sunset-[$current{sunrise}/$current{sunset}]");
    }
    else {
        $msg->send($woeid);
    }
}

sub condition_process {
    my ($woeid_param, $user_state) = @_; 
    my $ua = LWP::UserAgent->new;
    my %current;
    my @weekly;

    my $y_rep = $ua->get("http://weather.yahooapis.com/forecastrss?w=$woeid_param&u=c");
    
    if ($y_rep->is_success) {
        my $html = $y_rep->decoded_content;

        if ( $user_state eq 'current' ) {
            my ($condition, $temp, $date) = ($html =~ m{<yweather:condition  text="(.*?)"  code="\d+"  temp="(.*?)"  date="(.*?)" />}gsm);
            $current{condition} = $condition;
            $current{temp} = $temp;
            $current{date} = $date;
            my ($city, $country) = ($html =~ m{<yweather:location city="(.*?)" .*? country="(.*?)"/>}gsm); 
            $current{location} = "$country - $city";
            my ($chill, $direction, $speed) = ($html =~ m{<yweather:wind chill="(.+)"   direction="(.+)"   speed="(.*?)" />}gsm); 
            $current{chill} = $chill;
            $current{direction} = $direction;
            $current{speed} = $speed;
            my ($humidty, $visibility, $pressure, $rising) = ($html =~ m{<yweather:atmosphere humidity="(.+)"  visibility="(.*?)"  pressure="(.*?)"  rising="(.*?)" />}gsm); 
            $current{humidty} = $humidty;
            $current{visibility} = $visibility;
            $current{pressure} = $pressure;
            $current{rising} = $rising;
            my ($sunrise, $sunset) = ($html =~ m{<yweather:astronomy sunrise="(.*?)"   sunset="(.*?)"/>}gsm); 
            $current{sunrise} = $sunrise;
            $current{sunset} = $sunset;

            return %current;
        }
        elsif ( $user_state eq 'weekly' ) {
            my @weekly =  $html =~ m{<yweather:forecast day="(.*?)" date="(.*?)" low="(.*?)" high="(.*?)" text="(.*?)" code="\d+" />}gsm; 
            return @weekly;
        }

    }
    else {
        die $y_rep->status_line;
    }
}

sub woeid_process {
    my ($msg, $country) = @_; 
    my $param = "$country";
    my $error_msg = 'The name of the country or the city name wrong.';

    my $ua = LWP::UserAgent->new;

    my $rep = $ua->get("http://woeid.rosselliot.co.nz/lookup/$param");
    
    if ($rep->is_success) {
         my @woeid = $rep->decoded_content =~ m{data-woeid="(\d+)"}gsm;
         my @countrys = $rep->decoded_content =~ m{data-woeid="\d+"><td>.*?</td><td>.*?</td><td>(.*?)</td>}gsm;

         if ( $countrys[0] || $countrys[1]) {
            return "$woeid[0]";
         }
         elsif (!@woeid ) {
            return "$error_msg";
         }
         else {
             return $woeid[0];
         }
    }
    else {
        die $rep->status_line;
    }
}

1;

처음부터 살펴보겠습니다.
아래 부분은 실제 단어와 일치하면 동작하는 부분입니다.
sub load {
 	my ( $class, $robot ) = @_;
	# 1주일 날씨 예보를 보여줍니다.
 	$robot->hear(
	 	qr/^forecast (.+)/i,
	 	\&forecast_process,
	); 
	# 현재 날씨 예보를 보여줍니다.
 	$robot->hear(
 		qr/^weather (.+)/i,
 		&current_process,
	);
	# weather를 타이핑하기가 길어서 @로 대체하여 현재 날씨를 보여줍니다.
 	$robot->hear(
 		qr/^@(.+)$/i,
 		\&current_process,
 	);
}

일치하는 단어를 보면 forecast는 날씨예보이고, weather는 현재 날씨이며, @는 weather의 별칭입니다(weather 타이핑이 길어서..)
단어가 일치되면 해당 함수 레퍼런스에의해서 요청한 단어에 맞게 결과를 리턴하게 됩니다.

먼저 \&forecast_process 레퍼런스를 보면 아래와 같습니다.
sub forecast_process {
	my $msg = shift;
	my $user_country = $msg->match->[0];
	my $woeid = woeid_process($msg, $user_country);
	if ( $woeid =~ /^\d+/) {
		my @weekly = condition_process($woeid, 'weekly');
		$msg->send("[$weekly[0]"." $weekly[1]]"." Low/High[$weekly[2]℃ /$weekly[3]℃ ]"." Condition[$weekly[4]]");
		$msg->send("[$weekly[5]"." $weekly[6]]"." Low/High[$weekly[7]℃ /$weekly[8]℃ ]"." Condition[$weekly[9]]");
		$msg->send("[$weekly[10]"." $weekly[11]]"." Low/High[$weekly[12]℃ /$weekly[13]℃ ]"." Condition[$weekly[14]]");
		$msg->send("[$weekly[15]"." $weekly[16]]"." Low/High[$weekly[17]℃ /$weekly[18]℃ ]"." Condition[$weekly[19]]");
		$msg->send("[$weekly[20]"." $weekly[21]]"." Low/High[$weekly[22]℃ /$weekly[23]℃ ]"." Condition[$weekly[24]]");
	}
	else {
		$msg->send($woeid);
	}
}

forecast 분당이라고 입력했을경우

$msg 객체를 받습니다.  $msg객체는 아래와 같은 구조로  되어있습니다.
Hubot::Response {
	Parents Moose::Object
	public methods (14) : DESTROY, exist, finish, http, match, message, meta, new, random, reply, robot, send, topic, whisper
	private methods (0)
	internals: {
		match [
		[0] "분당"
		],
		message Hubot::TextMessage,
		robot Hubot::Robot
	}
}

구조를 잠시 보시면 Moose를 사용해서 객체를 만들었고 match메소드에는 일치된 단어가 들어 있습니다. 
그래서 일치된 분당이란 키워드를 가져와서 woeid_process 함수로 넘겨줍니다.
(woeid란 야후에서 제공하는 위치기반의  서비스입니다)
woeid_process함수는  아래와 같이 되어있으며 하는 일은 실제 일치된 단어를 http://woeid.rosselliot.co.nz/lookup에 던져서 
해당 지역의 woeid를 가져오는 역활을 수행합니다.
(woeid가 필요한건 위치기반 id로 yahoo api가 동작하기 때문입니다.)

sub woeid_process {
	my ($msg, $country) = @_;
	my $param = "$country";
	my $error_msg = 'The name of the country or the city name wrong.';
	my $ua = LWP::UserAgent->new;
	my $rep = $ua->get("http://woeid.rosselliot.co.nz/lookup/$param");
	
	if ($rep->is_success) {
		my @woeid = $rep->decoded_content =~ m{data-woeid="(\d+)"}gsm;
		my @countrys = $rep->decoded_content =~ m{data-woeid="\d+"><td>.*?</td><td>.*?</td><td>(.*?)</td>}gsm;
		if ( $countrys[0] || $countrys[1]) {
			return "$woeid[0]";
		}
		elsif (!@woeid ) {
			return "$error_msg";
		}
	else {
		return $woeid[0];
		}
	}
	else {
		die $rep->status_line;
	}
}

다시 forecast_process 함수를 보면  my @weekly = condition_process($woeid, 'weekly') 부분이 있는데 
condition_process함수는 실제 woeid를 가지고 yahoo api를 사용해 날씨정보를 가져오는 부분입니다.

woeid와 날짜기간을 받습니다. 날짜기간이 현재는 1주일과 현재날짜를 받게 되어있습니다.
current(현재날짜)를 받게되면 상세하게 날씨를 보여줍니다.

weekly를 받게되면 api에서 제공하는 간단한 예보를 보여줍니다.
예보는 해당 html의 문자열을 파싱하여 @weekly배열에 담아 보여주게 됩니다.
sub condition_process {
	my ($woeid_param, $user_state) = @_; 
	my $ua = LWP::UserAgent->new;
	my %current;
	my @weekly;
	my $y_rep = $ua->get("http://weather.yahooapis.com/forecastrss?w=$woeid_param&u=c");
	
	if ($y_rep->is_success) { #current(현재날짜)를 받게되면 상세하게 날씨를 보여줍니다.
		my $html = $y_rep->decoded_content;
		if ( $user_state eq 'current' ) {
			my ($condition, $temp, $date) = ($html =~ m{<yweather:condition text="(.*?)" code="\d+" temp="(.*?)" date="(.*?)" />}gsm);
			$current{condition} = $condition;
			$current{temp} = $temp;
			$current{date} = $date;
			my ($city, $country) = ($html =~ m{<yweather:location city="(.*?)" .*? country="(.*?)"/>}gsm);
			$current{location} = "$country - $city";
			my ($chill, $direction, $speed) = ($html =~ m{<yweather:wind chill="(.+)" direction="(.+)" speed="(.*?)" />}gsm);
			$current{chill} = $chill;
			$current{direction} = $direction;
			$current{speed} = $speed;
			my ($humidty, $visibility, $pressure, $rising) = ($html =~ m{<yweather:atmosphere humidity="(.+)" visibility="(.*?)" pressure="(.*?)" rising="(.*?)" />}gsm);
			$current{humidty} = $humidty;
			$current{visibility} = $visibility;
			$current{pressure} = $pressure;
			$current{rising} = $rising;
			my ($sunrise, $sunset) = ($html =~ m{<yweather:astronomy sunrise="(.*?)" sunset="(.*?)"/>}gsm);
			$current{sunrise} = $sunrise;
			$current{sunset} = $sunset;
			return %current;
		}
	elsif ( $user_state eq 'weekly' ) { #weekly를 받게되면 api에서 제공하는 간단한 예보를 보여줍니다.
		my @weekly = $html =~ m{<yweather:forecast day="(.*?)" date="(.*?)" low="(.*?)" high="(.*?)" text="(.*?)" code="\d+" />}gsm;
		return @weekly;
	}
	else {
		die $y_rep->status_line;
	}
}

\&forecast_process 함수를 정리하자면 이렇습니다.

sub load 함수 콜백에서 단어가 일치하면 해당 함수를 콜하고 
forecast_process함수는  $msg->match->[0]에 들어있는 지역의 woeid를 구하기위해 woeid_process함수에 넘기게 됩니다. 
woeid_process함수에서 해당 지역의 woeid를 구하면 
condition_process함수에 woeid를 넘겨서 yahoo api를 사용해 일치된 지역의 날씨정보를 가져오게 됩니다.

weather_process함수 또한 forecast_process함수와 같은 동작을 하게 되는데 weather는 현재날씨만을 보여줍니다.
그리고 weather 키워드가 길어서 @로대체한 것이 qr/^@(.+)$/i, 부분입니다.

실제 만들어진 Hubot 동작을 보면 아래와 같이 동작하는것을 알수 있습니다.

# forecast 분당
hubot> forecast 분당
[Mon 14 Dec 2015] Low/High[4℃ /8℃ ] Condition[Light Rain]
[Tue 15 Dec 2015] Low/High[0℃ /8℃ ] Condition[Mostly Cloudy]
[Wed 16 Dec 2015] Low/High[-5℃ /2℃ ] Condition[AM Snow Showers]
[Thu 17 Dec 2015] Low/High[-4℃ /1℃ ] Condition[Sunny]
[Fri 18 Dec 2015] Low/High[-3℃ /5℃ ] Condition[Partly Cloudy]

# weather 서울
hubot> weather 서울
South Korea - Seoul[ LastTime:Mon, 14 Dec 2015 3:58 pm KST ]
The status of current weather-[Light Rain] temp-[5℃ ] humidity-[81%] direction- [350km] speed-[9.66km/h] sunrise/sunset-[7:39 am/5:15 pm]

# @서울
hubot> @서울
South Korea - Seoul[ LastTime:Mon, 14 Dec 2015 3:58 pm KST ]
The status of current weather-[Light Rain] temp-[5℃ ] humidity-[81%] direction- [350km] speed-[9.66km/h] sunrise/sunset-[7:39 am/5:15 pm]

세계 각국의 날씨도 한번 해봅니다.
# @델리
hubot> @델리
India - Delhi[ LastTime:Mon, 14 Dec 2015 11:29 am IST ]
The status of current weather-[Haze] temp-[18℃ ] humidity-[50%] direction- [290km] speed-[14.48km/h] sunrise/sunset-[7:05 am/5:26 pm]

#@워싱턴
hubot> @워싱턴
United States - Washington[ LastTime:Mon, 14 Dec 2015 1:51 am EST ]
The status of current weather-[Fair] temp-[14℃ ] humidity-[89%] direction- [210km] speed-[8.05km/h] sunrise/sunset-[7:18 am/4:45 pm]

세계 각국의 날씨도 잘 되는것을 확인할 수 있습니다.
이제 한번 irc에서 실제 봇을 만들어서 공유 해보는건 어떨까요?

크리스마스 선물 #1
irc에 입장하는 사람마다 자동으로 날씨를 알리고 싶다면 어떻게 해야 할까요 ?
우선 입장하는 사람의 ip를 알아야 하고 ip기반의 위치(정확하지는 않지만요...)를 구한후에 woeid를 구해서 
condition_process 함수에 던지면 되겠죠?

한번 해볼까요?
사용자 접속 ip를 가져옵니다.
load 함수에 아래와 같은 hear를 구현합니다

$robot->hear(
	qr/@(\d+\.\d+\.\d+\.\d+$)/i,    
    \&station,
);

@ip 형식으로 일치가 되면 station함수를 실행합니다.
station함수는 ip를 가지고 위치를 구하는 함수입니다.
sub station {
    my $msg = shift;
    my $user_ip = $msg->match->[0];

    $msg->http("http://www.ip2location.com/$user_ip")->get (
        sub {
            my ($body, $hdr) = @_;

            return if ( !$body || $hdr->{Status} !~ /^2/ );

            my $decoded_body = decode("utf8", $body);
                if ( $decoded_body =~ m{<td><b>Weather Station</b></td>.*?<td>(.*?)</td>}gsm ) {
                    print $1;
                }
            }
        );
}

그럼 위치를 구했으면 woeid_process함수와 condition_process를 사용해서 날씨정보를 가져온뒤에 irc에 뿌려주면 되겠죠?


참고문서
Hubot - https://hubot.github.com/
HubotRepository - https://github.com/github/hubot-scripts
YahooWoeid - http://woeid.rosselliot.co.nz/lookup
YahooWeatherApis - http://weather.yahooapis.com/forecastrss
